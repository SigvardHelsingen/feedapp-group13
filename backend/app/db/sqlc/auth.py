# Code generated by sqlc. DO NOT EDIT.
# versions:
#   sqlc v1.30.0
# source: auth.sql
import datetime
from typing import Optional

import sqlalchemy
import sqlalchemy.ext.asyncio

from app.db.sqlc import models

CAN_USER_DO_AT = """-- name: can_user_do_at \\:one
SELECT can_user_do_at(
    :p1, :p2,
    :p3, :p4)
"""


MAKE_MODERATOR = """-- name: make_moderator \\:exec
INSERT INTO poll_grants (role, scope, user_id, expires_at)
VALUES ('moderator', 'user_global', :p1, :p2)
"""


REMOVE_MODERATOR = """-- name: remove_moderator \\:exec
UPDATE poll_grants SET expires_at = now()
WHERE user_id = :p1
    AND role = 'moderator'
    AND scope = 'user_global'
    AND now() <@ period
"""


class AsyncQuerier:
    def __init__(self, conn: sqlalchemy.ext.asyncio.AsyncConnection):
        self._conn = conn

    async def can_user_do_at(
        self,
        *,
        user_id: int,
        poll_id: int,
        permission: models.Permission,
        timestamp: Optional[datetime.datetime]
    ) -> Optional[bool]:
        row = (
            await self._conn.execute(
                sqlalchemy.text(CAN_USER_DO_AT),
                {
                    "p1": user_id,
                    "p2": poll_id,
                    "p3": permission,
                    "p4": timestamp,
                },
            )
        ).first()
        if row is None:
            return None
        return row[0]

    async def make_moderator(
        self, *, user_id: Optional[int], expires_at: Optional[datetime.datetime]
    ) -> None:
        await self._conn.execute(
            sqlalchemy.text(MAKE_MODERATOR), {"p1": user_id, "p2": expires_at}
        )

    async def remove_moderator(self, *, user_id: Optional[int]) -> None:
        await self._conn.execute(sqlalchemy.text(REMOVE_MODERATOR), {"p1": user_id})
