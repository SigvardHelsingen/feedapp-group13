# Code generated by sqlc. DO NOT EDIT.
# versions:
#   sqlc v1.30.0
# source: poll.sql
import datetime
from typing import Any, AsyncIterator, List, Optional

import pydantic
import sqlalchemy
import sqlalchemy.ext.asyncio

from app.db.sqlc import models

ASSIGN_PUBLIC_PERMS = """-- name: assign_public_perms \\:exec
INSERT INTO poll_grants (role, scope, poll_id)
VALUES (:p1, 'public_poll', :p2)
"""


ASSIGN_ROLE = """-- name: assign_role \\:exec
INSERT INTO poll_grants (role, scope, user_id, poll_id)
VALUES (:p1, 'user_poll', :p2, :p3)
"""


CREATE_POLL = """-- name: create_poll \\:one
INSERT INTO poll (question, created_by, expires_at)
VALUES (:p1, :p2, :p3)
RETURNING id
"""


CREATE_VOTE_OPTION = """-- name: create_vote_option \\:exec
INSERT INTO vote_option (caption, poll_id, presentation_order)
VALUES (:p1, :p2, :p3)
"""


DELETE_GRANTS_FOR_POLL = """-- name: delete_grants_for_poll \\:exec
DELETE FROM poll_grants WHERE poll_id = :p1
"""


DELETE_POLL = """-- name: delete_poll \\:exec
DELETE FROM poll WHERE id = :p1
"""


DELETE_VOTE_OPTIONS_FOR_POLL = """-- name: delete_vote_options_for_poll \\:exec
DELETE FROM vote_option WHERE poll_id = :p1
"""


GET_POLL = """-- name: get_poll \\:one
SELECT p.id, p.question, p.expires_at, u.username as creator_name,
    array_agg(vo.caption ORDER BY vo.presentation_order)\\:\\:text[] AS options,
    array_agg(vo.id ORDER BY vo.presentation_order)\\:\\:bigint[] AS option_ids,
    max(v.vote_option_id) as user_vote
FROM poll p
INNER JOIN vote_option vo ON p.id = vo.poll_id
INNER JOIN "user" u ON p.created_by = u.id
LEFT JOIN vote v ON v.vote_option_id = vo.id AND v.user_id = :p1
WHERE p.id = :p2 AND can_user_do_at(:p1, :p2, 'poll\\:view')
GROUP BY p.id, u.id
"""


class GetPollRow(pydantic.BaseModel):
    id: int
    question: str
    expires_at: Optional[datetime.datetime]
    creator_name: str
    options: List[str]
    option_ids: List[int]
    user_vote: Any


GET_POLLS = """-- name: get_polls \\:many
SELECT p.id, p.question, p.expires_at, u.username as creator_name,
    array_agg(vo.caption ORDER BY vo.presentation_order)\\:\\:text[] AS options,
    array_agg(vo.id ORDER BY vo.presentation_order)\\:\\:bigint[] AS option_ids
FROM poll p
INNER JOIN vote_option vo ON p.id = vo.poll_id
INNER JOIN "user" u ON p.created_by = u.id
WHERE can_user_do_at(:p1, p.id, 'poll\\:view')
GROUP BY p.id, u.id
"""


class GetPollsRow(pydantic.BaseModel):
    id: int
    question: str
    expires_at: Optional[datetime.datetime]
    creator_name: str
    options: List[str]
    option_ids: List[int]


class AsyncQuerier:
    def __init__(self, conn: sqlalchemy.ext.asyncio.AsyncConnection):
        self._conn = conn

    async def assign_public_perms(
        self, *, role: models.Role, poll_id: Optional[int]
    ) -> None:
        await self._conn.execute(
            sqlalchemy.text(ASSIGN_PUBLIC_PERMS), {"p1": role, "p2": poll_id}
        )

    async def assign_role(
        self, *, role: models.Role, user_id: Optional[int], poll_id: Optional[int]
    ) -> None:
        await self._conn.execute(
            sqlalchemy.text(ASSIGN_ROLE), {"p1": role, "p2": user_id, "p3": poll_id}
        )

    async def create_poll(
        self, *, question: str, created_by: int, expires_at: Optional[datetime.datetime]
    ) -> Optional[int]:
        row = (
            await self._conn.execute(
                sqlalchemy.text(CREATE_POLL),
                {"p1": question, "p2": created_by, "p3": expires_at},
            )
        ).first()
        if row is None:
            return None
        return row[0]

    async def create_vote_option(
        self, *, caption: str, poll_id: int, presentation_order: int
    ) -> None:
        await self._conn.execute(
            sqlalchemy.text(CREATE_VOTE_OPTION),
            {"p1": caption, "p2": poll_id, "p3": presentation_order},
        )

    async def delete_grants_for_poll(self, *, poll_id: Optional[int]) -> None:
        await self._conn.execute(
            sqlalchemy.text(DELETE_GRANTS_FOR_POLL), {"p1": poll_id}
        )

    async def delete_poll(self, *, id: int) -> None:
        await self._conn.execute(sqlalchemy.text(DELETE_POLL), {"p1": id})

    async def delete_vote_options_for_poll(self, *, poll_id: int) -> None:
        await self._conn.execute(
            sqlalchemy.text(DELETE_VOTE_OPTIONS_FOR_POLL), {"p1": poll_id}
        )

    async def get_poll(
        self, *, user_id: Optional[int], poll_id: int
    ) -> Optional[GetPollRow]:
        row = (
            await self._conn.execute(
                sqlalchemy.text(GET_POLL), {"p1": user_id, "p2": poll_id}
            )
        ).first()
        if row is None:
            return None
        return GetPollRow(
            id=row[0],
            question=row[1],
            expires_at=row[2],
            creator_name=row[3],
            options=row[4],
            option_ids=row[5],
            user_vote=row[6],
        )

    async def get_polls(self, *, user_id: Optional[int]) -> AsyncIterator[GetPollsRow]:
        result = await self._conn.stream(sqlalchemy.text(GET_POLLS), {"p1": user_id})
        async for row in result:
            yield GetPollsRow(
                id=row[0],
                question=row[1],
                expires_at=row[2],
                creator_name=row[3],
                options=row[4],
                option_ids=row[5],
            )
