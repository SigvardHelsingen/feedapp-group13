# Code generated by sqlc. DO NOT EDIT.
# versions:
#   sqlc v1.30.0
# source: vote.sql
from typing import AsyncIterator

import pydantic
import sqlalchemy
import sqlalchemy.ext.asyncio

from app.db.sqlc import models

DELETE_USER_VOTE_ON_POLL = """-- name: delete_user_vote_on_poll \\:exec
DELETE FROM vote
WHERE vote_option_id IN (
    SELECT id FROM vote_option WHERE poll_id = :p1
) AND user_id = :p2
"""


GET_VOTE_COUNTS = """-- name: get_vote_counts \\:many
SELECT vo.id as vote_option_id, vo.caption, count(v.id) AS vote_count
FROM poll p
INNER JOIN vote_option vo ON p.id = vo.poll_id
INNER JOIN vote v ON v.poll_option_id = vo.id
WHERE p.id = :p1
GROUP BY vo.id
ORDER BY vo.presentation_order
"""


class GetVoteCountsRow(pydantic.BaseModel):
    vote_option_id: int
    caption: str
    vote_count: int


SUBMIT_VOTE = """-- name: submit_vote \\:exec
INSERT INTO vote (user_id, vote_option_id)
VALUES (:p1, :p2)
"""


class AsyncQuerier:
    def __init__(self, conn: sqlalchemy.ext.asyncio.AsyncConnection):
        self._conn = conn

    async def delete_user_vote_on_poll(self, *, poll_id: int, user_id: int) -> None:
        await self._conn.execute(
            sqlalchemy.text(DELETE_USER_VOTE_ON_POLL), {"p1": poll_id, "p2": user_id}
        )

    async def get_vote_counts(self, *, id: int) -> AsyncIterator[GetVoteCountsRow]:
        result = await self._conn.stream(sqlalchemy.text(GET_VOTE_COUNTS), {"p1": id})
        async for row in result:
            yield GetVoteCountsRow(
                vote_option_id=row[0],
                caption=row[1],
                vote_count=row[2],
            )

    async def submit_vote(self, *, user_id: int, vote_option_id: int) -> None:
        await self._conn.execute(
            sqlalchemy.text(SUBMIT_VOTE), {"p1": user_id, "p2": vote_option_id}
        )
